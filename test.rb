def test(title, &b)
  begin
    if b
      b.call
    else
      puts "pending: #{title}"
    end
  rescue => e
    puts "fail: #{title}"
    puts e
  end
end

def assert(statement)
  if statement
    puts "pass"
  else
    puts "fail"
  end
end

def assert_equal(actual, expected)
  if expected == actual
    puts 'pass'
  else
    puts "fail: expected #{expected}, got #{actual}"
  end
end

# Part 1: Object Models

# Create a Class for song, artist, and genre. Use an individual file for each class.
# These files should be placed within a lib directory and required on the top of
# any script that utilizes them (including this test script). Once required
# all the tests within this suite should pass.

# Artist Specs
test 'Can initialize an Artist' do
  assert Artist.new
end

test 'An artist can have a name' do
  artist = Artist.new
  artist.name = "Adele"
  assert_equal artist.name, "Adele"
end

test "An artist has songs" do
  artist = Artist.new
  artist.songs = []
  assert_equal artist.songs, []
end

test 'The Artist class can reset the artists that have been created' do
  assert Artist.reset_artists
  assert_equal Artist.count, 0
end

test 'The Artist class can keep track of artists as they are created' do
  assert Artist.all
end

test 'The Artist class can count how many artists have been created' do
  assert Artist.count
end

test 'artists have songs' do
  artist = Artist.new
  songs = (1..4).collect{|i| Song.new}
  artist.songs = songs

  assert_equal artist.songs, songs
end

test 'An artist can count how many songs they have' do
  artist = Artist.new
  songs = [Song.new, Song.new]
  artist.songs = songs

  assert_equal artist.songs_count, 2
end

test 'a song can be added to an artist' do
  artist = Artist.new
  song = Song.new
  artist.add_song(song)

  assert artist.songs.include?(song)
end

test 'artists have genres' do
  artist = Artist.new
  song = Song.new
  song.genre = Genre.new.tap{|g| g.name = 'rap'}
  artist.add_song(song)

  assert artist.genres.include?(song)
end

# Genre Specs
test 'Can initialize a genre' do
  assert Genre.new
end

test 'A genre has a name' do
  genre = Genre.new
  genre.name = 'rap'

  assert_equal genre.name, 'rap'
end

test 'A genre has many songs' do
  genre = Genre.new.tap{|g| g.name = 'rap'}
  [1,2].each do
    song = Song.new
    song.genre = genre
  end

  assert_equal genre.songs.count, 2
end

test 'A genre has many artists' do
  genre = Genre.new.tap{|g| g.name = 'rap'}

  [1,2].each do
    artist = Artist.new
    song = Song.new
    song.genre = genre
    artist.add_song(song)
  end

  assert_equal genre.artists.count, 2
end

test 'A genres Artists are unique' do
  genre = Genre.new.tap{|g| g.name = 'rap'}
  artist = Artist.new

  [1,2].each do
    song = Song.new
    song.genre = genre
    artist.add_song(song)
  end

  assert_equal genre.artists.count, 1
end

# Same behavior as Artists
test 'The Genre class can keep track of all created genres' do
  Genre.reset_genres # You must implement a method like this
  genres = [1..5].collect do |i|
    Genre.new
  end

  assert_equal Genre.all, genres
end

# Extra Credit
# Complete any song test that is pending (undefined).
# The functionality described must still be present to complete the assignment
# so even if you do not complete the pending specs, they must pass in my complete
# test suite. There's no way you'd be able to accomplish the site generation
# without your song class having this functionality, so go ahead and try
# to use assert and assert_equal to write some tests.

test 'Can initialize a song'
test 'A song can have a name'
test 'A song can have a genre'
test 'A song has an artist'

# write a ruby script that parses the data within the data directory
# and uses the classes defined above to instantiate Song, Artist, and Genres
# for each file. These instances should be correctly associated to each other
# so that artist.genre will return a Genre object, etc.

# This script should additionally Generate a website that has the following sections:
# An index page that links to the two sections of the sites, artists and genres

  # index.html
    # links to artist.html
    # links to genres.html

  # This index page does not need to be generated by the application, you can just manually
  # create it. However, it must contain

# Templates should be generated via ERB files located in lib/views.

# artists.html
# The artist index must list all the artists. This list must be sorted alphabetically.
# In addition to the Artists name, the artists total song count should be displayed.
# The artist name should linke to the artists individual page within site/artists.
# This page should also say how many Artists there are in total.

# artists/<artist>.html
# The script must generate an artist page for each individual artist that was created
# during import. An artists page should list the name of the artist along with their songs
# and genres. The songs and genres must link to the individual song and genre page.

# genres.html
# The genre index must list all the genres. This list must be sorted by the amount of songs.
# In addition to the Genres name, the total song and artist count should be listed along side it.
# The genre name should linke to the genres individual page within site/genres.

# genres/<genre>.html
# The script must generate a genre page for each individual genre that was created
# during import. A genres page should list the name of the songs, linking to the individual
# song and artists. Also include the total unique artists and song counts in the genre.

# songs/<song>.html
# The song page should list all the available information on the song, it's artist and genre
# with the appropriate links.

# Extra Credit:
# Use a ruby module somewhere to refactor common functionality.
